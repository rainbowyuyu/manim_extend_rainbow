# rainbow_yu manim_extend.basic_unit.squ_tex üêã‚ú®
# Êï∞ÊçÆÂùóÁ≠âÂä®ÁîªÂü∫Êú¨ÁöÑÁ±ª

from ..disposition.fonts_and_colors import *

__all__ = (
    "typedict",
    "SquTex",
    "SquTexSlide",
)


class SquTex(VGroup):
    """
    Êï∞ÊçÆÂùóÔºå
    ÁªßÊâø‰∫é :class:`~.VGroup` Ôºå

    Notes
    -----

    - Â∏∏Áî®‰∫éÊï∞ÊçÆÁªìÊûÑÁöÑÊºîÁ§∫Âíå‰∫åËøõÂà∂ÁºñÁ†ÅÁöÑÊºîÁ§∫Ôºå
    - Â∞ÜÊñπÂùóÂíåÊï∞Â≠óÊï¥ÂêàÂú®‰∏ÄËµ∑ÔºåÊîØÊåÅÁªü‰∏ÄÁöÑÂä®ÁîªÂíåÂçï‰∏™Âä®ÁîªÔºå
    - :param:`distance` ÊàêÂëòËÆ∞ÂΩï‰∫ÜÁ¨¨‰∏ÄÊ¨°ÊûÑÈÄ†Êï∞ÊçÆÈó¥ÁöÑÈó¥Ë∑ù
    - Âçï‰∏™Âä®Áîª‰ΩøÁî® :method:`animate_one_by_one` Â∞ÜÂä®ÁîªÁºñ‰∏∫‰∏Ä‰∏™ÁªÑ
    - Âú®ÂàõÂª∫Êï∞ÊçÆÂùóÊó∂ÔºåÊääÊâÄÊúâÁöÑÂèØÂèòÂèÇÊï∞ kwargs ËµãÁªô‰∫Ü :class:`~.Square` Á±ª„ÄÇ
    - Â¶ÇÊûúÈúÄË¶ÅÊîπÂèòÂÖ∂‰ªñÂèÇÊï∞Ôºå‰ΩøÁî® :method:`change_square` ‰ª•Âèä :method:`change_text`Ôºå
    - ‰ΩÜË¶ÅÊ≥®ÊÑè‰ΩøÁî® :method:`change_text` Êó∂‰ºöÂ∞ÜÂéüÂØπË±°ÁöÑÂ±ÇÊ¨°ÊîπÂèò„ÄÇ
    - ‰ΩøÁî® :method:`add_bracket` Â∞ÜÊï∞ÊçÆÂùó‰∏≠ÊâÄÊúâË¥üÊï∞ÁöÑÊï∞Â≠óÈÉΩÂä†‰∏äÊã¨Âè∑

    Examples
    --------

    ÂàõÂª∫Êï∞ÊçÆÂùó:

    >>> class SquTexCreate(Scene):
    >>>     def construct(self):
    >>>         t = SquTex("rainbow")
    >>>         self.play(t.animate_one_by_one(FadeIn , scale=1.5))
    >>>         self.wait()

    Êï∞ÊçÆÂùóÊ†∑ÂºèÊîπÂèò:

    >>> class SquTexChangeStyle(Scene):
    >>>     def construct(self):
    >>>         t = SquTex("rainbow",**typedict["default_type"])
    >>>         arg = (1,3,4)
    >>>         self.add(t)
    >>>         self.wait()
    >>>         self.play(t.animate.change_square(*arg,color = GOLD,fill_opacity = 0),)
    >>>         self.play(t.animate.change_text(1,2,5,color = RED),)
    >>>         self.wait()

    """

    def __init__(
            self,
            tex: str | list,
            font="",
            buff=0,
            arrange_direction=RIGHT,
            text_type=Text,
            str_need_split=True,
            **kwargs
    ):
        self.tex = tex
        self.buff = buff
        self.arrange_direction = arrange_direction
        self.distance = np.array((0.0, 0.0, 0.0))
        self.font = font
        self.settings = kwargs
        self.text_type = text_type
        self.str_need_split = str_need_split
        self.kwargs = kwargs

        super().__init__()
        if self.str_need_split:
            try:
                self._default_type()
            except IndexError:
                self._without_split_type()
        else:
            self._without_split_type()
        self._construct()

    def _default_type(self):
        """
        Âü∫Á°ÄÊ¨æÁöÑÈªòËÆ§ÊûÑÈÄ†
        :return: self
        """
        if self.text_type is MathTex:
            for i in range(len(self.tex)):
                v = VGroup(
                    Square(**self.kwargs),
                    MathTex(f"{self.tex[i]}"),
                )
                self.add(v)
        else:
            for i in range(len(self.tex)):
                v = VGroup(
                    Square(**self.kwargs),
                    Text(f"{self.tex[i]}", font=self.font),
                )
                self.add(v)
        return self

    def _without_split_type(self):
        """
        ‰∏çÂàÜÈöîÁöÑÊûÑÈÄ†ÊñπÂºè
        :return: self
        """
        v = VGroup(
            Square(**self.kwargs),
        )
        if self.text_type is MathTex:
            v.add(self.text_type(self.tex))
        else:
            v.add(self.text_type(self.tex, font=self.font))
        self.add(v)
        return self

    def _construct(self):
        """
        ‰ΩçÁΩÆÁöÑÊûÑÈÄ†
        :return: self
        """
        self.arrange(buff=self.buff, direction=self.arrange_direction)
        self.update_distance()
        return self

    def update_distance(self):
        """
        Êõ¥Êñ∞ÊØè‰∏™Âùó‰πãÈó¥ÁöÑË∑ùÁ¶ª
        :return: self
        """
        cp = self[0].copy()
        cp.next_to(self[0], self.arrange_direction, buff=self.buff)
        self.distance = np.array((
            cp.get_center()[0] - self[0].get_center()[0],
            cp.get_center()[1] - self[0].get_center()[1],
            cp.get_center()[2] - self[0].get_center()[2],
        ))
        return self

    def add_bracket(
            self,
            index: int
    ):
        """
        Âçï‰∏™Ê∑ªÂä†Êã¨Âè∑
        :param index: ‰ΩçÁΩÆ
        :return: self
        """
        left_bracket = Text("(").next_to(self[index], LEFT, buff=-0.2)
        right_bracket = Text(")").next_to(self[index], RIGHT, buff=-0.2)
        self[index].add(left_bracket, right_bracket)
        return self

    def animate_one_by_one(
            self,
            animation_func,
            lag=None,
            **kwargs
    ):
        """
        ÈÄê‰∏™ËøêË°åÂä®Áîª
        :param animation_func:Âä®ÁîªÊñπÂºè
        :param lag:Âª∂ËøüÊó∂Èó¥
        :return:Âä®ÁîªÁªÑ
        """

        if lag is None:
            lag = 0.5
        animations = [animation_func(v, **kwargs) for v in self]
        return AnimationGroup(*animations, lag_ratio=lag)

    def change_square(
            self,
            *args,
            **kwargs,
    ):
        """
        Áõ¥Êé•ÊîπÂèòÊñπÂùóÈ°πÁöÑÂèÇÊï∞
        :param args: ÂèØÂèòÂèÇÊï∞ÔºåËÆ∞ÂΩï‰∫ÜÊîπÂèòÊ†∑ÂºèÁöÑ‰ΩçÁΩÆ
        :param kwargs: ÂèØÂèòÂ≠óÂÖ∏ÔºåËÆ∞ÂΩï‰∫ÜÊîπÂèòÁöÑÊ†∑Âºè
        :return: self
        """

        for i in args:
            self[i][0].set(**kwargs)
        return self

    def change_text(
            self,
            *args,
            **kwargs,
    ):
        """
        Áõ¥Êé•ÊîπÂèòÊñáÂ≠óÈ°πÁöÑÂèÇÊï∞
        :param args: ÂèØÂèòÂèÇÊï∞ÔºåËÆ∞ÂΩï‰∫ÜÊîπÂèòÊ†∑ÂºèÁöÑ‰ΩçÁΩÆ
        :param kwargs: ÂèØÂèòÂ≠óÂÖ∏ÔºåËÆ∞ÂΩï‰∫ÜÊîπÂèòÁöÑÊ†∑Âºè
        :return: self
        """

        for i in args:
            self[i][1].set(**kwargs)
        return self

    def change_word_in_text(
            self,
            index: int,
            text=None,
            scale_factor=1,
            **kwargs
    ):
        """
        ÊîπÂèòÂçï‰∏™ÊñáÂ≠óÈ°πÁöÑÊñáÂ≠óÂíåÂèÇÊï∞
        :param scale_factor: Â§ßÂ∞è
        :param index: ‰ΩçÁΩÆ
        :param text: ÊñáÂ≠ó
        :param kwargs: ÂèØÂèòÂèÇÊï∞
        :return: self
        """
        if text is None:
            text = self.tex[index]
        self[index][1] = Text(f"{text}", font=self.font, **kwargs).scale(scale_factor)
        self[index][1].move_to(self[index][0])
        return self

    def get_tex_lst(
            self,
            return_type=str,
    ):
        """
        Ëé∑ÂèñSquTex‰∏≠ÁöÑÊñáÂ≠óÂàóË°®
        :param return_type:ËøîÂõûÊ†ºÂºèÔºöÂåÖÂê´ `int` Âíå `str`
        :return: Êõ¥Êñ∞Âú®self.tex‰∏≠ÁöÑÊñáÂ≠óÂàóË°®
        """
        self.tex = []
        for i in range(len(self)):
            if return_type is str:
                self.tex.extend(self[i][1].original_text)
            elif return_type is int:
                self.tex.append(int(self[i][1].original_text))
            else:
                raise TypeError("return_type must be `str` or `int`")
        return self.tex

    def get_color_lst(self):
        """
        Ëé∑ÂèñSquTex‰∏≠ÁöÑÈ¢úËâ≤ÂàóË°®
        :return: È¢úËâ≤ÂàóË°®
        """
        color_lst = []
        for i in range(len(self)):
            color_lst.append(self[i][1].color)
        return color_lst


class SquTexSlide(SquTex):
    """
    ÊºîÁ§∫ÊªëÂä®ÁöÑÊï∞ÊçÆÂùóÔºå
    ÁªßÊâø‰∫é :class:`~.SquTex` Ôºå

    Notes
    -----

    - Âú®Êï∞ÊçÆÂùóÁöÑÂü∫Á°Ä‰∏äÊ∑ªÂä†ÊªëÂä®ÁöÑÂä®ÁîªÔºå
    - ‰ΩøÁî® :method:`pop` Âíå :method:`push` ÂÆåÊàêÂü∫Êú¨Ê†àÂíåÈòüÂàóÁöÑÂéãÂÖ•ÂíåÂºπÂá∫
    - ‰ΩøÁî® :method:`slide` ÂÅöÂü∫Êú¨ÁöÑ‰ΩçÁΩÆÂèòÂåñÊªëÂä®
    - ‰ΩøÁî® :method:`slide_fade` ÂÅöÊï∞ÊçÆÂùóÂÜÖÈÉ®ÊàñÂ§ñÈÉ®Ê∑ªÂä†ÁöÑÂæ™ÁéØÊªëÂä®ÔºåÂπ∂‰∏îÂ§¥Â∞æÁºìÂÖ•ÁºìÂá∫

    Examples
    --------

    Ê†àÂíåÈòüÂàóÁöÑÂéãÂÖ•ÂºπÂá∫ :method:`pop` Âíå :method:`push`:

    >>> class StackTest(Scene):
    >>>     def construct(self):
    >>>         s = SquTexSlide("ra")
    >>>         p1 = SquTexSlide("i")
    >>>         p2 = SquTexSlide("n")
    >>>         self.add(s)
    >>>         self.play(*s.push(p1,2,force_center=True))
    >>>         self.play(*s.push(p2,3,force_center=True))
    >>>         for i in range(3):
    >>>             self.play(*s.pop(0,force_center=True))
    >>>         self.wait()

    Âü∫Á°ÄÊªëÂä® :method:`slide`:

    >>> class SquTexSlideBasic(Scene):
    >>>     def construct(self):
    >>>         s = SquTexSlide("rainbow")
    >>>         self.add(s)
    >>>         self.wait()
    >>>         for i in range(len(s)):
    >>>             self.play(*s.slide(-1))
    >>>         self.wait()

    Âæ™ÁéØÊªëÂä®Â§¥Â∞æÁºìÂÖ•ÁºìÂá∫ :method:`slide_fade`:

    >>> class SquTexSlideFadeRotate(Scene):
    >>>     def construct(self):
    >>>         a = SquTexSlide("rainbow")
    >>>         self.add(a)
    >>>         self.play(*a.slide_fade(2))

    Â§ñÈÉ®Ê∑ªÂä†ÊªëÂä®Â§¥Â∞æÁºìÂÖ•ÁºìÂá∫ÁªìÂêàÂ∫îÁî® :method:`slide_fade`:

    >>> class SquTexSlideFadeAddition(Scene):
    >>>     def construct(self):
    >>>         a = SquTexSlide("yty123")
    >>>         b = SquTex("ab")
    >>>         self.add(a)
    >>>         self.play(*a.slide_fade('forward',b))
    >>>         self.play(*a.slide_fade(2))

    """

    def __init__(
            self,
            tex: str | list,
            **kwargs,
    ):
        super().__init__(tex, **kwargs)

    def pop(
            self,
            index: int = -1,
            force_center=False
    ):
        """
        ÂºπÂá∫Âä®Áîª
        :param index: ‰ΩçÁΩÆ
        :param force_center: Âº∫Âà∂Â±Ö‰∏≠
        :return: all_the_animate
        """
        all_the_animate = []
        center = self.get_center()
        cp = self.copy()

        popped = self[index]
        self.remove(popped)
        all_the_animate.append(
            FadeOut(popped, shift=np.array((self.distance[1], -self.distance[0], 0))),
        )
        for i in range(index, len(self)):
            all_the_animate.append(self[i].animate.move_to(cp[i]))
        if force_center:
            all_the_animate.append(self.animate.move_to(center))
        return all_the_animate

    def push(
            self,
            st_input: SquTex | str | int,
            index=None,
            force_center=False,
    ):
        """
        Êé®ÂÖ•Âä®Áîª
        :param index: ‰ΩçÁΩÆ
        :param st_input: Âä†ÂÖ•ÁöÑÊï∞ÊçÆÂùó
        :param force_center: Âº∫Âà∂Â±Ö‰∏≠
        :return: all_the_animate
        """
        cp = self.copy()
        all_the_animate = []

        st_color = self.get_color()

        if isinstance(st_input, SquTex):
            st_color = st_input.get_color()
            st_input = st_input.tex

        st_input = SquTexSlide(f"{st_input}", font=self.font, **self.settings).set_color(st_color)

        if index is None or index == len(self):
            st_input.next_to(self, direction=self.arrange_direction, buff=self.buff)
            self.add(st_input)
            all_the_animate.append(
                FadeIn(st_input, shift=np.array((self.distance[1], -self.distance[0], 0))),
            )
        else:
            st_input.move_to(cp[index])
            for i in range(index, len(self)):
                all_the_animate.append(self[i].animate.shift(self.distance))
            all_the_animate.append(
                FadeIn(st_input, shift=np.array((self.distance[1], -self.distance[0], 0))),
            )
            self.insert(index, st_input)

        if force_center:
            all_the_animate.append(self.animate.arrange(direction=self.arrange_direction, buff=self.buff))

        return all_the_animate

    def _slide_order(
            self,
            direction: int,
            st_input: SquTex = None
    ):
        """
        ÂÜÖÁΩÆÂáΩÊï∞Ôºå‰æø‰∫éÊéßÂà∂Êï∞ÊçÆÂùóÊªëÂä®ÂêéËøîÂõûÁöÑself‰ΩçÁΩÆ‰ªçÁÑ∂Ê≠£Á°Æ
        :param direction: ÊñπÂêëÔºöÊ≠£Êï∞‰∏∫Ê≠£ÊñπÂêëÔºåË¥üÊï∞‰∏∫Ë¥üÊñπÂêë
        :param st_input: Â§ñÈÉ®Âä†ÂÖ•ÁöÑÊï∞ÊçÆÂùó
        :return: self
        """
        if direction < 0:
            for i in range(abs(direction)):
                popped = self[0]
                self.remove(popped)
                if st_input is None:
                    self.add(popped)
                else:
                    self.add(st_input[i])
        elif direction > 0:
            for i in range(direction):
                popped = self[-1]
                self.remove(popped)
                if st_input is None:
                    self.insert(0, popped)
                else:
                    self.insert(0, st_input[-i-1])
        elif direction == 0:
            pass
        return self

    def slide(
            self,
            direction: int,
    ):
        """
        - Âü∫Êú¨Êï∞ÊçÆÂùóÊªëÂä®
        - Âä®ÁîªÁªÑÔºå‰ΩøÁî®playÊó∂ÈúÄË¶ÅËøõË°åÂ∫èÂàóËß£ÂåÖ

        :param direction: ÊñπÂêëÔºöÊ≠£Êï∞‰∏∫Ê≠£ÊñπÂêëÔºåË¥üÊï∞‰∏∫Ë¥üÊñπÂêë
        :return: all_the_animate
        """
        all_the_animate = []
        cp = self.copy()
        for i in range(len(self)):
            all_the_animate.append(
                self[i].animate.move_to(cp[(len(self) + i + direction) % len(self)])
            )
        self._slide_order(direction)
        return all_the_animate

    def slide_fade(
            self,
            direction: int | str,
            st_input: SquTex = None,
    ):
        """
        - ÁºìÂÖ•ÁºìÂá∫ÊªëÂä®ÂÜÖÈÉ®Âæ™ÁéØÊàñÂ§ñÈÉ®Ê∑ªÂä†Êï∞ÊçÆÂùó
        - Âä®ÁîªÁªÑÔºå‰ΩøÁî®playÊó∂ÈúÄË¶ÅËøõË°åÂ∫èÂàóËß£ÂåÖ
        :param direction:
            ÊñπÂêëÔºö
            Âú®ÂÜÖÈÉ®Âæ™ÁéØÊó∂ÈááÁî®Êï¥Êï∞Ê†ºÂºèÔºöÊ≠£Êï∞‰∏∫Ê≠£ÊñπÂêëÔºåË¥üÊï∞‰∏∫Ë¥üÊñπÂêëÔºåÊï∞ÂÄº‰∏∫ÊªëÂä®ÁöÑÂùóÊï∞Ôºõ
            ÂΩìÊ∑ªÂä†Â§ñÈÉ®Êï∞ÊçÆÂùóÊó∂ÈááÁî®Â≠óÁ¨¶‰∏≤Ê†ºÂºèÔºö'forward'‰∏∫Ê≠£ÊñπÂêëÔºå'backward'‰∏∫Ë¥üÊñπÂêëÔºåÊªëÂä®ÂùóÊï∞Ëá™Âä®‰∏∫Ê∑ªÂä†ÁöÑÂùóÊï∞
        :param st_input:  ËæìÂÖ•ÁöÑÊï∞ÊçÆÂùó
        :return: all_the_animation
        """

        # Ê†ºÂºèÊ£ÄÊµã
        if isinstance(direction, int) and st_input is None:
            if 2 * direction > len(self):
                raise ValueError(f"{direction}ÂøÖÈ°ªÂ∞è‰∫éÁ≠â‰∫é{len(self) // 2}ÔºåÂê¶ÂàôÊó†Ê≥ïËøõË°åÊ∏êÂèòÊìç‰Ωú")
        elif isinstance(direction, str) and st_input and isinstance(st_input, SquTex):
            if direction == 'forward':
                direction = len(st_input)
            elif direction == 'backward':
                direction = -len(st_input)
            else:
                raise ValueError(f"ËæìÂÖ•Êï∞ÊçÆÂùóËøõË°åÊªëÂä®Êó∂{direction}‰∏çÂåπÈÖçÔºå‰ΩøÁî®'forward'Âíå'backward'Ë°®Á§∫ÊñπÂêë")
        else:
            raise ValueError(f"‰ΩøÁî®slide_fadeÊó∂directrion:{direction}Âíåst_input:{st_input}ÈúÄËæìÂÖ•Ê≠£Á°ÆÊ†ºÂºè")

        all_the_animate = []
        cp = self.copy()

        # Âü∫Á°ÄmoveÂä®Áîª
        for i in range(
            0 if direction > 0 else abs(direction),
            len(self) - direction if direction > 0 else len(self),
        ):
            all_the_animate.append(
                self[i].animate.move_to(cp[(len(self) + i + direction) % len(self)])
            )

        # Fade ioÂä®Áîª
        out_vgp = self[-direction:] if direction > 0 else self[:-direction]
        out_cp = out_vgp.copy()
        all_the_animate.append(FadeOut(out_cp, shift=direction * self.distance))
        if st_input:
            out_vgp = st_input
        out_vgp.next_to(
            cp[(len(self) + direction) % len(self)]
            if direction > 0 else
            cp[(len(self) - 1 + direction) % len(self)],
            direction=(-direction) * self.distance,
            buff=self.buff,
        )
        all_the_animate.append(FadeIn(out_vgp, shift=direction * self.distance))

        self._slide_order(direction, st_input)
        return all_the_animate


class Stack(SquTexSlide):
    """
    Â±ïÁ§∫Ê†àÁªìÊûÑÁöÑÊï∞ÊçÆÂ∫ì
    ÁªßÊâø‰∫é :class:`~.SquTexSlide` Ôºå

    Notes
    -----

    - Âú®ÊªëÂä®Êï∞ÊçÆÂùóÁöÑÂü∫Á°Ä‰∏äÊ∑ªÂä†Êï∞ÊçÆÁªìÊûÑÁöÑÂèòÊç¢ÁâπÊÄßÔºå
    - ‰ΩøÁî® :method:`swap` ÂÆåÊàê‰∏§Êï∞ÊçÆÂùóÁöÑ‰∫§Êç¢
    - ‰ΩøÁî® :method:`reverse` ÂÆåÊàêÊüê‰∏™Êï∞ÊçÆ‰ΩçÁΩÆÂêéÁöÑÁøªËΩ¨
    - ‰ΩøÁî® :method:`add_pointer` Ê∑ªÂä†ÁâπÂÆö‰ΩçÁΩÆÁöÑÊåáÈíà

    Examples
    --------

    """
    def __init__(
            self,
            tex: str | list,
            **kwargs,
    ):
        super().__init__(tex, **kwargs)
